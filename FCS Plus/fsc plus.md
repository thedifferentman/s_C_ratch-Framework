# 说明书

------

我原神还没玩呢就搁这优化这个说明书防止你们看不懂，我泰善辣！！！

前情提要：如果你懒得看，你至少要阅读一下核心功能 `scf`。

0. ###### 替代符

- ###### `$reg`: 寄存器，一般情况下写作 `$reg(const int x)`，表示`$reg`中的值偏移`x`后所得的地址对应的寄存器，其中 `$0(x)` 可简写为 `$x`。看清楚！！是“值”偏移 `x` 后的“寄存器”！！不是这个寄存器的地址直接偏移！！

- ###### 特殊寄存器

|          名称           |                 概述                 |         地址          |
| :---------------------: | :----------------------------------: | :-------------------: |
|          `$0`           |       `0` 寄存器，存储常量 `0`       |         `$0`          |
|          `$ax`          |   大部分时间作为运算结果的存放地址   |       `$99999`        |
| `$bx` `$cx` `$dx` `$ex` |            常用寄存器别名            | `$100000` - `$100003` |
|          `$st`          |        栈顶指针（改动为正栈）        |       `$100004`       |
|          `$PC`          | 程序计数器（就是当前运行到第几行了） |       `$199999`       |

- ###### `警告!` `$0` 寄存器的值应为常量 `0`，尽量不要动它。

- ###### `不警告！` FSC 有一个隐藏机制，因为 scratch 列表没有第 0 项，所以给所有地址都右移了 1。然而 FSC Plus 严格使用原位指令，因此 `$0` 本身就不可修改。你随便动，出事了算我输。

- ###### `val`: 可读值，可以是 `寄存器` 或 `数字常量`。

- ###### `避雷！` 你们可能没用过 FSC。有些地方具有迷惑性我给大家避一下雷。这个 `$st` 不要以为它代表的地址是栈顶。它代表的地址永远都是 `$100004`！而 `$100004` 中存储的值才是栈顶的地址！换句话说，栈顶不是 `$st`，而是 `$st(0)`！！有人（肯定不是我，你说对吧）可能会因为以下原因踩雷：*如果它中存的数才是代表栈顶的，那 `push` 和 `pop` 指令不就没用了？用 `add` 和 `mov` 替代不就行了？所以肯定栈顶就是 `$st` 啊*。……你说的还真对（）所以我把 `push` 和 `pop` 删了，这样就没有迷惑性了。

1. ###### 基本指令

|       指令       |                    操作                    |      例子      |
| :--------------: | :----------------------------------------: | :------------: |
| `mov $reg, val`  |           将值 `val` 存入 `$reg`           |  `mov $ax, 0`  |
| `add $reg, val`  |           将 `$reg` 加上值 `val`           |  `add $ax, 1`  |
| `sub $reg, val`  |           将 `$reg` 减去值 `val`           | `sub $ax, $bx` |
| `mul $reg, val`  |           将 `$reg` 乘以值 `val`           |  `mul $ax, 1`  |
| `div $reg, val`  |           将 `$reg` 除以值 `val`           |  `div $ax, 1`  |
| `pow val0, val1` |     计算 `val0` ^ `val1` 并存入 `$ax`      |  `pow $1, 2`   |
| `mod val0, val1` | 计算 `val0` 除以 `val1` 的余数并存入 `$ax` | `mod $ax, 100` |
|    `abs val`     |      计算 `val` 的绝对值并存入 `$ax`       |   `abs $ax`    |
|    `cil val`     |        将 `val` 向上取整存入 `$ax`         |   `cil $ax`    |
|    `flr val`     |        将 `val` 向下取整存入 `$ax`         |   `flr $ax`    |
|    `sqr val`     |    计算 `val` 的算术平方根并存入 `$ax`     |   `sqr $ax`    |
|    `sin val`     |      计算 `val` 的正弦值并存入 `$ax`       |   `sin $ax`    |
|    `cos val`     |      计算 `val` 的余弦值并存入 `$ax`       |   `cos $ax`    |
|    `tan val`     |      计算 `val` 的正切值并存入 `$ax`       |   `tan $ax`    |
|    `asin val`    |     计算 `val` 的反正弦值并存入 `$ax`      |   `asin $ax`   |
|    `acos val`    |     计算 `val` 的反余弦值并存入 `$ax`      |   `acos $ax`   |
|    `atan val`    |     计算 `val` 的反正切值并存入 `$ax`      |   `atan $ax`   |
|     `ln val`     |     计算 `val` 的自然对数并存入 `$ax`      |    `ln $ax`    |
|    `log val`     | 计算 `val` 以 `10` 为底的对数并存入 `$ax`  |   `log $ax`    |
|    `exp val`     |     计算 `e` 的 `val` 次幂并存入 `$ax`     |   `exp $ax`    |

- ###### 这里点名批评 FSC，`mod` 的指令格式写错了（

2. ###### 逻辑指令

|       指令       |                      操作                      |      例子      |
| :--------------: | :--------------------------------------------: | :------------: |
| `eq val0, val1`  | 判断 `val0` 与 `val1` 的值是否相等并存入 `$ax` | `eq $ax, $bx`  |
| `grt val0, val1` |  判断 `val0` 的值是否大于 `val1` 并存入 `$ax`  | `grt $ax, $bx` |
| `les val0, val1` |  判断 `val0` 的值是否小于 `val1` 并存入 `$ax`  | `les $ax, $bx` |
| `and val0, val1` |               且运算，存入 `$ax`               | `and $ax, $bx` |
| `or val0, val1`  |               或运算，存入 `$ax`               | `or $ax, $bx`  |
| `xor val0, val1` |              异或运算，存入 `$ax`              | `xor $ax, $bx` |
|    `not $reg`    |             否运算，对 `$reg` 取反             |   `not $ax`    |

3. ###### 流程指令

|   指令    |        操作         |   例子   |
| :-------: | :-----------------: | :------: |
| `jmp val` |     无条件跳转      | `jmp 10` |
| `jz val`  | `$ax` 值不为 0 跳转 | `jz 10`  |
| `jnz val` |  `$ax` 值为 0 跳转  | `jnz 10` |

- ###### 这里注意不要犯惯性思维，很容易看到 ’n‘ 联想到 “not”。看仔细，`jz` 才是“不”为 0。

- ###### `注意！` FSC 更适合手写汇编，而 FSC Plus 更适合作为高级语言编译的目标代码。s·C·ratch 高级开发框架的 C 语言编译器的内存分配策略中上一个 `top_sp` 指针存储在了栈中的控制链区，上一个 `PC` 指针存储在了机器状态字中，因此不需要依赖汇编语言本身具有的函数调用回跳功能，而是利用栈中存储的信息来直接 `jmp`。所以我删除了 `call` 和 `ret` 指令，这两个指令对手写汇编的用户比较友好，对于编译器来说意义不大。

4. ###### 其他指令

|       指令       |                         操作                         |     例子      |
| :--------------: | :--------------------------------------------------: | :-----------: |
|    `rand val`    |          将`0` - `val`中随机一个数存入`$ax`          |  `rand 100`   |
|    `disp val`    |                     输出到控制台                     |  `disp $ax`   |
|    `exit val`    |                退出，值为0为正常退出                 |   `exit 0`    |
| `scf val0, val1` | 调用 scratch 中编号为 `val1` 的函数，传递参数 `val2` | `scf 1 99999` |

- ###### `避雷` 不用显式使用 `exit` 也照样能正常退出。

- ###### 我删除了 `tick` 指令，这意味着如果直接使用不刷新屏幕就会导致屏幕永远不能刷新。FSC 暂时使用了 `tick` 来刷新屏幕，但是这会影响性能，比如（假设没有解锁帧率）在 1/30 秒内刷新两次是没有意义的。而很幸运的是一年前已经有了 [Timing Refresh](https://aerfaying.com/Projects/1253624) 技术，而 FSC Plus 的预处理器使得运行模拟为单循环结构，这种结构对 Timing Refresh 的兼容性极好，于是我决定为 FSC Plus 适配 Timing Refresh，这样就可以在高速运行的同时自动刷新屏幕了。

- ###### `核心功能` FSC Plus 最核心的新增功能就是 `scf` 指令，它可以调用 scratch 的函数。具体实现需要用户自行操作。在源代码中有一个叫 `call_scratch_function` 的函数，先写如果那么的分支来区分不同的 `id`，然后对于每一个 `id` 分别调用一次这个 `id` 对应的函数（具体是哪个函数你自己决定），并将 `arg` 作为参数。你可能想问：*这就一个参数啊，我要是想传多个参数怎么办？* 很简单，只需要传一个地址（就是一个数，但是这个数表示一个地址），然后这个地址往后的若干个数代表参数列表。有了这一功能，s·C·ratch 完爆 scratch。

------

# NOW SHARE YOUR OWN PROGRAM IN FSC PLUS!